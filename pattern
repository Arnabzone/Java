
1. Opposite Ends PatternThis logic is used when you need to compare elements from both sides 
of a collection.

FUNCTION TwoPointerOpposite(array, target):
    left = 0
    right = array.length - 1

    WHILE left < right:
        current_val = array[left] + array[right]
        
        IF current_val == target:
            RETURN (left, right)
        ELSE IF current_val < target:
            left = left + 1    // Move right to increase value
        ELSE:
            right = right - 1  // Move left to decrease value
            
    RETURN NOT_FOUND


2. Fast and Slow PointersCommonly used for linked structures to detect loops or find midpoints.
    
    FUNCTION FastAndSlow(head):
    slow = head
    fast = head

    WHILE fast is not null AND fast.next is not null:
        slow = slow.next          // 1 step
        fast = fast.next.next     // 2 steps
        
        IF slow == fast:          // Pointers meet
            RETURN TRUE (Cycle Detected)
            
    RETURN FALSE (End reached)

3. Sliding Window (Two Pointers)
Used to find a sub-segment of data that satisfies a specific constraint.
    
    FUNCTION SlidingWindow(array, constraint):
    left = 0
    max_result = 0
    current_state = 0

    FOR right FROM 0 TO array.length - 1:
        Add array[right] to current_state
        
        // Shrink window from the left until constraint is met
        WHILE current_state violates constraint:
            Remove array[left] from current_state
            left = left + 1
            
        // Window is now valid, record its size
        window_size = right - left + 1
        max_result = MAX(max_result, window_size)
        
    RETURN max_result
Comparison of Movement 
LogicPattern            Left Pointer Movement Right Pointer 
MovementOpposite        Increments ($+1$)Decrements ($-1$)

Fast/Slow               Moves 1 step        Moves 2 steps
)